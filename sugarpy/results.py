#!/usr/bin/env python3.5
# encoding: utf-8

# '''
# SugarPy - discovery-driven analysis of glycan compositions from IS-CID
# of intact glycopeptides.

# Copyright (c) 2016 S. Schulze, J. Kraegenbring, A. Oltmann, C. Fufezan,
# M. Hippler

#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.

#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.

#     You should have received a copy of the GNU General Public License
#     along with this program.  If not, see <http://www.gnu.org/licenses/>.
# '''

from __future__ import absolute_import
from collections import namedtuple
from collections import defaultdict as ddict
import sugarpy
import ursgal
import sys
import pymzml
from pymzml.plot import Factory
import csv
import os
import plotly
import plotly.graph_objs as go
import re
import numpy as np
import pickle


class Results(dict):
    '''
    SugarPy results are stored as a SugarPy results class in the Python pickle format.
    Employing functions from the results class allows to e.g.:
        - write results as CSV files (write_results2csv)
        - plot elution profiles (plot_glycan_elution_profile)
        - plot annotated spectra (plot_annotated_spectra)

    The SugarPy results class itself is a dictionary that contains all scored_glycans 
    as well as the spec_collector for each peptide:
    dict = {
        peptide_unimod : {
            'scored_glycans': {
                spec1 : {
                    glycan_tuple1 : {
                        'tree_length': int
                        'SugarPy_score': float,
                        'num_subtrees': int,
                        'suc0r': set,
                        'formula': str,
                        'subtrees': list,
                    },
                    glycan_tuple1 : ...
                },
                spec2 : ...
            },                              
            'spec_collector': { 
                spec1 : { 
                    formula1 : {
                        'vector' : list,
                        'charge' : list,
                        'trivial_name' : list,
                        'glycan_comp' : list,
                        'glycan_trees' : list,
                    },
                    formula2 : ...
                },
                spec2: ...
            }
        }
    }
    '''

    def __init__(
        self,
        scan_rt_lookup={},
        validated_results=None,
        monosaccharides={},
    ):
        self.scan_rt_lookup = scan_rt_lookup
        if validated_results is not None:
            for k, v in validated_results.items():
                self[k] = v
        self.monosaccharides = monosaccharides
        # globals()['SPS_key'] = namedtuple(
        #     'SPS_key',
        #     sorted(monosaccharides.keys()) + ['End']
        # )

    def add_results(
        self,
        peptide_unimod=None,
        spec_collector=None,
        scored_glycans=None,
    ):
        '''
        Adds results to the SugarPy results class

        Keyword Arguments:
            peptide_unimod (str): peptide#unimod
            spec_collector (dict):
                dictionary returned by run.sort_results()
            scored_glycans (dict):
                dictionary generated by run.validate_results()
        '''
        if peptide_unimod not in self.keys():
            self[peptide_unimod] = {}
        self[peptide_unimod]['scored_glycans'] = scored_glycans
        self[peptide_unimod]['spec_collector'] = spec_collector
        return self

    def write_results2csv(
        self,
        output_file=None,
        max_trees_per_spec=5,
        min_sugarpy_score=0,
        min_sub_cov=0.0,
        peptide_lookup=None,
        monosaccharides=None,
        scan_rt_lookup=None,
        mzml_basename=None
    ):
        '''
        Return a csv file containing a summary of all results stored in the results class

        Keyword Arguments:
            output_file (str): output file name
            max_trees_per_spec (int):
                maximum number of glycan compositions returned for one spectrum
            min_sugarpy_score (float):
                minimum SugarPy score (glycan compositions with lower scores are not returned)
            min_sub_cov (float):
                minimum subtree coverage (glycan compositions with sub_cov are not returned)
            peptide_lookup (dict):
                dictionary returned by run.parse_ident_file()
            monosaccharides (dict): 
                dictionary containing name and chemical composition of monosaccharides
            scan_rt_lookup (dict):
                dictionary containing the retention time for each spectrum
            mzml_basename (str): name of the mzML or sample

        Returns:
            str: output file name
        '''
        if monosaccharides is None:
            monosaccharides = self.monosaccharides

        csv_fieldnames = [
            'Raw Data Name',
            'Spectrum ID',
            'Sequence',
            'Modifications',
            'Glycan',
            'SugarPy Score',
            'Protein ID',
            'Subtree Coverage',
            'Num of Subtrees',
            'Chemical Formula',
            'Charges',
            'Calc m/z',
            'Exp m/z',
            'Accuracy (ppm)',
            'Retention Time [min]',
        ]
        print('[ SugarPy  ] Writing results ...')
        for monosacch in sorted(monosaccharides.keys()):
            csv_fieldnames.append(monosacch)
        csv_fieldnames.append('End')

        opened_output_file = open(output_file, 'w')

        if sys.platform == 'win32':
            lineterminator = '\n'
        else:
            lineterminator = '\r\n'
        csv_writer = csv.DictWriter(
            opened_output_file, csv_fieldnames, lineterminator=lineterminator)
        csv_writer.writeheader()

        for peptide_unimod in sorted(self.keys()):
            print('write results for:', peptide_unimod)
            scored_glycans = self[peptide_unimod]['scored_glycans']
            spec_collector = self[peptide_unimod]['spec_collector']
            for spec, scored_glycan_trees in sorted(scored_glycans.items()):
                if scored_glycan_trees == {}:
                    continue
                rt = scan_rt_lookup[spec]
                sorted_glycans = self.sort_glycan_trees(
                    scored_glycan_trees=scored_glycan_trees,
                    tuple_pos=1,
                    sort_by='SugarPy_score',
                )
                if '#' in peptide_unimod:
                    peptide, mods = peptide_unimod.split('#')
                else:
                    peptide = peptide_unimod
                    mods = ''
                csv_dict = {}
                csv_dict['Retention Time [min]'] = rt
                csv_dict['Spectrum ID'] = spec
                csv_dict['Sequence'] = peptide
                csv_dict['Modifications'] = mods
                csv_dict['Raw Data Name'] = mzml_basename
                counter = 0
                for score in sorted(sorted_glycans.keys(), reverse=True):
                    if score < min_sugarpy_score or counter >= max_trees_per_spec:
                        break
                    for glycan in sorted_glycans[score]:
                        if scored_glycan_trees[glycan]['sub_cov'] >= min_sub_cov:
                            counter += 1
                            cc = ursgal.ChemicalComposition()
                            cc.use(peptide_unimod)
                            csv_dict['SugarPy Score'] = score
                            csv_dict['Subtree Coverage'] = scored_glycan_trees[
                                glycan]['sub_cov']
                            csv_dict['Num of Subtrees'] = scored_glycan_trees[
                                glycan]['num_subtrees']
                            name = ''
                            for monosacch, count in glycan:
                                name += '{0}({1})'.format(monosacch, count)
                                csv_dict[monosacch] = count
                                if monosacch == 'End':
                                    continue
                                for c in range(0, count):
                                    cc.add_chemical_formula(
                                        monosaccharides[monosacch])
                            formula = cc.hill_notation_unimod()
                            csv_dict['Chemical Formula'] = formula
                            charges = spec_collector[spec][formula]['charge']
                            csv_dict['Charges'] = ';'.join(
                                [str(c) for c in charges]
                            )
                            calc_mzs = []
                            measured_mzs = []
                            ppms = []
                            for pos, charge in enumerate(charges):
                                calc_mz = ursgal.ucore.calculate_mz(
                                    cc._mass(),
                                    charge
                                )
                                calc_mzs.append(str(calc_mz))
                                measured_mz = spec_collector[spec][
                                    formula]['vector'][pos]['peaks'][0][0]
                                measured_mzs.append(str(measured_mz))
                                if measured_mz == None:
                                    ppms.append('None')
                                    continue
                                ppms.append(
                                    str((measured_mz - calc_mz) / measured_mz * 1000000))
                            csv_dict['Calc m/z'] = ';'.join(calc_mzs)
                            csv_dict['Exp m/z'] = ';'.join(measured_mzs)
                            csv_dict['Accuracy (ppm)'] = ';'.join(ppms)
                            csv_dict['Glycan'] = name
                            csv_dict['Protein ID'] = peptide_lookup[
                                peptide_unimod]['protein']
                            csv_writer.writerow(csv_dict)
        print('[ SugarPy  ] Results can be found here: ', output_file)
        opened_output_file.close()
        return output_file

    def sort_glycan_trees(
        self,
        scored_glycan_trees=None,
        tuple_pos=1,
        sort_by='SugarPy_score'
    ):
        '''
        Sort glycan composition e.g. by the SugarPy_score.

        Returns:
            dict
        '''
        sorted_glycans = {}
        for glycan in sorted(scored_glycan_trees.keys(), key=lambda tup: tup[tuple_pos]):
            if scored_glycan_trees[glycan][sort_by] not in sorted_glycans.keys():
                sorted_glycans[scored_glycan_trees[glycan][sort_by]] = []
            sorted_glycans[scored_glycan_trees[glycan][sort_by]].append(glycan)
        return sorted_glycans

    def parse_result_file(self, result_file, return_type='plot', min_spec_number=1):
        '''
        Parses a SugarPy results .csv file and extracts identified peptides
        together with their glycans and charges.

        Arguments:
            result_file (str): Path to the SugarPy result .csv file.
            return_type (str): 'plot' or 'peak_presence'

        Returns:
            dict: The dict contains all identified peptidoforms (Peptide#Unimod:Pos),
                as keys and a dict with the glycans (keys) and {'charges':set(), 'file_names':set()} (value)
                as values
        '''
        print('[ SugarPy  ] Parsing SugarPy result file')
        
        if return_type == 'plot':
            plot_molecule_dict = {}
            with open(result_file, 'r') as in_file:
                csv_input = csv.DictReader(in_file)
                for line_dict in csv_input:
                    if line_dict['Modifications'] != '':
                        pep = '{0}#{1}'.format(
                            line_dict['Sequence'], line_dict['Modifications'])
                    else:
                        pep = line_dict['Sequence']
                    if pep not in plot_molecule_dict.keys():
                        plot_molecule_dict[pep] = {}
                    plot_molecule = line_dict['Glycan']
                    charges = line_dict['Charges'].split(';')
                    if plot_molecule not in plot_molecule_dict[pep].keys():
                        plot_molecule_dict[pep][plot_molecule] = {
                            'charges': [],
                            'file_names' : [],
                            'specs': [],
                        }
                    plot_molecule_dict[pep][plot_molecule]['charges'].append(
                        [int(c) for c in charges]
                    )
                    plot_molecule_dict[pep][plot_molecule]['file_names'].append(
                        line_dict['Raw Data Name']
                    )
                    plot_molecule_dict[pep][plot_molecule]['specs'].append(
                        int(line_dict['Spectrum ID'])
                    )
            return plot_molecule_dict

        elif return_type == 'peak_presence':
            formula_to_rt = ddict(list)
            molecule_name_dict = ddict(set)
            rt_list = []
            # charge_set = set()
            line_dict_list = []
            molecule_spec_count = ddict(set)
            with open(result_file, 'r') as in_file:
                csv_input = csv.DictReader(in_file)
                csv_fieldnames = csv_input.fieldnames
                peak_presence_dict = None
                for header in csv_fieldnames:
                    if 'MS1 Spectrum IDs (without IS-CID)' in header:
                        peak_presence_dict = {}
                        ms1_header = header
                    if 'MS2 Spectrum IDs (without IS-CID)' in header:
                        peak_presence_dict = {}
                        ms2_header = header
                for line_dict in csv_input:
                    spec = line_dict['Spectrum ID']
                    formula = line_dict['Chemical Formula']
                    if peak_presence_dict is not None:
                        if formula not in peak_presence_dict.keys():
                            peak_presence_dict[formula] = {
                                'ms1_peak_specs': set(),
                                'ms2_frag_specs': set()
                            }
                        for s in line_dict[ms1_header].split(';'):
                            if s != '':
                                peak_presence_dict[formula]['ms1_peak_specs'].add(int(s))
                        for s in line_dict[ms2_header].split(';'):
                            if s != '':
                                peak_presence_dict[formula]['ms2_frag_specs'].add(int(s))
                    molecule = '#'.join(
                        [
                            line_dict['Sequence'],
                            line_dict['Modifications'],
                            line_dict['Glycan'],
                        ]
                    )
                    formula_to_rt[formula].append(
                        float(line_dict['Retention Time [min]'])
                    )
                    molecule_spec_count[molecule].add(spec)
                    if len(molecule_spec_count[molecule]) >= min_spec_number:
                        molecule_name_dict[formula].add(molecule)
                    rt_list.append(float(line_dict['Retention Time [min]']))
                    # charges = line_dict['Charges'].split(';')
                    # for charge in charges:
                    #     charge_set.add(int(charge))
                    line_dict_list.append(line_dict)
            if peak_presence_dict is not None:
                for formula in molecule_name_dict.keys():
                    peak_presence_dict[formula]['name_list'] = sorted(molecule_name_dict[formula])
            return formula_to_rt, molecule_name_dict, rt_list, line_dict_list, csv_fieldnames, molecule_spec_count, peak_presence_dict

        else:
            print("[ERROR] Not clear how to parse result file, please specify 'plot' or 'peak_presence'")
            sys.exit(1)

    def plot_molecule_elution_profile(
        self,
        plot_molecule_dict=None,
        output_file=None,
        title=None,
        include_subtrees='no_subtrees',
        monosaccharides=None,
        scan_rt_lookup=None,
        x_axis_type='retention_time',
        plotly_layout=None,
    ):
        '''
        Plot elution profile for molecules (chemical compositions).
        This can be used e.g. to plot separate elution profiles for fragmetn ions
        of a glycan composition
        '''
        x_axis_list = []
        y_axis_list = []
        text_list = []
        plot_name_list = []
        plot_dict = {}

        if monosaccharides is None:
            monosaccharides = self.monosaccharides
        if scan_rt_lookup is None:
            scan_rt_lookup = self.scan_rt_lookup

        # globals()['SPS_key'] = namedtuple(
        #     'SPS_key',
        #     sorted(monosaccharides.keys()) + ['End']
        # )

        if plot_molecule_dict is None or plot_molecule_dict == {}:
            print('[ SugarPy  ] Nothing to plot here (plot_elution_profile)')
            print('[ SugarPy  ] for file:', output_file)
            return

        for peptide_unimod in sorted(self.keys()):
            scored_glycans = self[peptide_unimod]['scored_glycans']
            spec_collector = self[peptide_unimod]['spec_collector']
            if peptide_unimod not in plot_molecule_dict.keys():
                continue
            for spec in sorted(scored_glycans.keys()):
                rt = scan_rt_lookup[spec]
                formula_dict = {}
                for p, plot_molecule in enumerate(plot_molecule_dict[peptide_unimod].keys()):
                    sp_tuple = self.glycan_to_tuple(plot_molecule)
                    all_charges = plot_molecule_dict[
                        peptide_unimod][plot_molecule]['charges']
                    charges = set()
                    for charge_list in all_charges:
                        for c in charge_list:
                            charges.add(c)
                    if sp_tuple not in scored_glycans[spec]:
                        continue
                    glycan_val_dict = scored_glycans[spec][sp_tuple]
                    name = plot_molecule
                    formula = glycan_val_dict['formula']
                    if formula in formula_dict.keys():
                        # different glycans can have same formula
                        # make them unique by adding index
                        formula += '|{0}'.format(p)
                    formula_dict[formula] = {
                        'formula_list': [formula.split('|')[0]],
                        'charges': sorted(charges),
                        'p': p,
                        'name': name,
                    }
                    if include_subtrees != 'no_subtrees':
                        for sub_formula in glycan_val_dict['subtrees']:
                            formula_dict[formula][
                                'formula_list'].append(sub_formula)
                for formula in formula_dict.keys():
                    for c in formula_dict[formula]['charges']:
                        sf_list = []
                        name_list = []
                        # real_formula = formula.split('|')[0]
                        for sub_formula in formula_dict[formula]['formula_list']:
                            if c not in spec_collector[spec][sub_formula]['charge']:
                                continue
                            charge_i = spec_collector[spec][sub_formula][
                                'charge'].index(c)
                            sf_list.append(spec_collector[spec][sub_formula][
                                'vector'][charge_i]['scaling_factor'])
                            trivial_name = spec_collector[spec][
                                sub_formula]['trivial_name'][0]
                            if type(trivial_name) is list:
                                trivial_name = '<|>'.join(trivial_name)
                            name_list.append(trivial_name)
                        if sf_list == []:
                            continue
                        if include_subtrees == 'sum_subtrees':
                            scaling_factor = [sum(sf_list)]
                            name_list = [name_list[0]]
                        elif include_subtrees == 'individual_subtrees':
                            scaling_factor = sf_list
                        elif include_subtrees == 'no_subtrees':
                            scaling_factor = sf_list
                        else:
                            print(
                                'Error: {0} is not allowed for "include_subtrees"'.format(
                                    include_subtrees
                                )
                            )
                            sys.exit(1)
                        for i, label in enumerate(name_list):
                            text = ''
                            # if len(name) >= 2:
                            #     label = '<|>'.join(name)
                            # else:
                            #     label = name[0]
                            for n in label.split('<|>'):
                                text += '{0}<br>'.format(n)
                            if label not in plot_dict.keys():
                                plot_dict[label] = {
                                    'x_axis' : [],
                                    'y_axis' : [],
                                    'text'   : [],
                                }
                            if x_axis_type == 'spectrum_id':
                                plot_dict[label]['x_axis'].append(spec)
                            elif x_axis_type == 'retention_time':
                                plot_dict[label]['x_axis'].append(rt)
                            else:
                                print(
                                    '''
                                    x_axis_type {0} is unknown!
                                    Use "spectrum_id" or "retention_time"
                                    '''.format(
                                        x_axis_type
                                    )
                                )
                                sys.exit(1)
                            plot_dict[label]['y_axis'].append(
                                scaling_factor[i])
                            plot_dict[label]['text'].append(text)

        for label in plot_dict.keys():
            x_axis_list.append(plot_dict[label]['x_axis'])
            y_axis_list.append(plot_dict[label]['y_axis'])
            text_list.append(plot_dict[label]['text'])
            plot_name_list.append(label)

        sorted_name_list, sorted_x_axis_list, sorted_y_axis_list, sorted_text_list = \
            self.sort_plot_lists(
                name_list=plot_name_list,
                x_axis_list=x_axis_list,
                y_axis_list=y_axis_list,
                text_list=text_list
            )
        if x_axis_type == 'spectrum_id':
            title_x = 'Spectrum ID'
        elif x_axis_type == 'retention_time':
            title_x = 'Retention Time [min]'
        else:
            print(
                '''
                x_axis_type {0} is unknown!
                Use "spectrum_id" or "retention_time"
                '''.format(
                    x_axis_type
                )
            )
            sys.exit(1)

        self.plot_scatter_vec_id(
            x_axis_list=sorted_x_axis_list,
            y_axis_list=sorted_y_axis_list,
            text_list=sorted_text_list,
            name_list=sorted_name_list,
            output_file=output_file,
            x_axis_name=title_x,
            y_axis_name='Scaling Factor',
            title=title,
            plotly_layout=plotly_layout,
        )
        print('[ SugarPy  ] Plotted molecule elution profile:', output_file)
        return output_file

    def plot_glycan_elution_profile(
        self,
        peptide_list=None,
        min_sugarpy_score=0,
        min_sub_cov=0.0,
        x_axis_type='retention_time',
        score_type='top_score',
        output_file=None,
        title=None,
        scan_rt_lookup=None,
        plotly_layout=None,
        # print_subtrees=False,
    ):
        '''
        Plot elution profile(s) for identified glycopeptide(s)

        Keyword Arguments:
            peptide_list (list): list of peptide#unimod for which elution profiles should be plotted
            output_file (str): output file name
            min_sugarpy_score (float):
                minimum SugarPy score (glycan compositions with lower scores are not returned)
            min_sub_cov (float):
                minimum subtree coverage (glycan compositions with sub_cov are not returned)
            x_axis_type (str): 
                Plot by spectrum_id or retention_time (x-axis)
            score_type (dict):
                Plot by best score (top_score) or sum of scores (sum_scores) for each spectrum (y-axis)
            title (str): Title of plot
            plotly_layout (dict): plotly layout used for the plot

        Returns:
            str: output file name
        '''
        x_axis_list = []
        y_axis_list = []
        text_list = []
        name_list = []
        plot_dict = {}

        if scan_rt_lookup is None:
            scan_rt_lookup = self.scan_rt_lookup

        for peptide_unimod in sorted(self.keys()):
            # if '#' in peptide_unimod:
            #     peptide_unimod = peptide_unimod.strip('#')
            # print(peptide_unimod)
            scored_glycans = self[peptide_unimod]['scored_glycans']
            spec_collector = self[peptide_unimod]['spec_collector']
            if peptide_list is not None and peptide_unimod not in peptide_list:
                continue
            for spec, scored_glycan_trees in sorted(scored_glycans.items()):
                # print(spec)
                if scored_glycan_trees == {}:
                    continue
                append_spec = False
                sum_scores = 0
                top_score = 0
                text = ''

                sorted_glycans = self.sort_glycan_trees(
                    scored_glycan_trees=scored_glycan_trees,
                    tuple_pos=1,
                    sort_by='SugarPy_score',
                )

                for score in sorted(sorted_glycans.keys(), reverse=True):
                    for glycan in sorted_glycans[score]:
                        name = ''
                        if scored_glycan_trees[glycan]['sub_cov'] < min_sub_cov:
                            continue
                        if scored_glycan_trees[glycan]['SugarPy_score'] < min_sugarpy_score:
                            continue
                        append_spec = True
                        for monosacch, count in glycan:
                            name += '{0}({1})'.format(monosacch, count)
                        sum_scores += scored_glycan_trees[
                            glycan]['SugarPy_score']
                        if top_score < scored_glycan_trees[glycan]['SugarPy_score']:
                            top_score = scored_glycan_trees[
                                glycan]['SugarPy_score']
                        text += '{0} SugarPy_score:{1} sub_cov: {2} num_subtrees: {3}<br>'.format(
                            name,
                            round(scored_glycan_trees[glycan][
                                  'SugarPy_score'], 2),
                            round(scored_glycan_trees[
                                  glycan]['sub_cov'], 2),
                            scored_glycan_trees[glycan]['num_subtrees'],
                        )
                        # if print_subtrees == True:
                        #     text += 'subtrees:<br>'
                        #     for subtree in scored_glycan_trees[glycan]['subtrees']:
                        #         sub_name = ''
                        #         for monosacch, count in subtree:
                        #             sub_name += '{0}({1})'.format(monosacch, count)
                        #         text += '{0}<br>'.format(sub_name)
                        #     text += '<br>'
                if append_spec == True:
                    if peptide_unimod not in plot_dict.keys():
                        plot_dict[peptide_unimod] = {
                            'x_axis' : [],
                            'y_axis' : [],
                            'text' : [],
                        }
                    if x_axis_type == 'spectrum_id':
                        plot_dict[peptide_unimod]['x_axis'].append(spec)
                        x_axis_name = 'Spectrum ID'
                    elif x_axis_type == 'retention_time':
                        rt = self.scan_rt_lookup[spec]
                        plot_dict[peptide_unimod]['x_axis'].append(rt)
                        x_axis_name = 'Retention Time [min]'
                    else:
                        print(
                            '''
                            x_axis_type {0} is unknown!
                            Use "spectrum_id" or "retention_time"
                            '''.format(
                                x_axis_type
                            )
                        )
                        sys.exit(1)
                    if score_type == 'top_scores':
                        plot_dict[peptide_unimod]['y_axis'].append(top_score)
                        y_axis_name = 'Top SugarPy Scores'
                    elif score_type == 'sum_scores':
                        plot_dict[peptide_unimod]['y_axis'].append(sum_scores)
                        y_axis_name = 'Sum of SugarPy Scores'
                    else:
                        print(
                            '''
                            score_type {0} is unknown!
                            Use "sum_scores" or "top_scores"
                            '''.format(
                                score_type
                            )
                        )
                        sys.exit(1)
                    plot_dict[peptide_unimod]['text'].append(text)

        for peptide in plot_dict.keys():
            x_axis_list.append(plot_dict[peptide]['x_axis'])
            y_axis_list.append(plot_dict[peptide]['y_axis'])
            text_list.append(plot_dict[peptide]['text'])
            name_list.append(peptide)

        if plot_dict == {}:
            print('[ SugarPy  ] Nothing to plot here (plot_glycan_profile)')
            print('[ SugarPy  ] for file:', output_file)
            return
        sorted_name_list, sorted_x_axis_list, sorted_y_axis_list, sorted_text_list = \
            self.sort_plot_lists(
                name_list=name_list,
                x_axis_list=x_axis_list,
                y_axis_list=y_axis_list,
                text_list=text_list
            )
        self.plot_scatter_vec_id(
            x_axis_list=sorted_x_axis_list,
            y_axis_list=sorted_y_axis_list,
            text_list=sorted_text_list,
            name_list=sorted_name_list,
            title=title,
            x_axis_name=x_axis_name,
            y_axis_name=y_axis_name,
            output_file=output_file,
            plotly_layout=plotly_layout,
        )
        print('[ SugarPy  ] Plotted glycan elution profile:', output_file)
        return output_file

    def glycan_to_tuple(self, glycan):
        '''
        Converts a glycan (unimod style: Hex(2)HexNAc(5)) into a tuple 
        of (monosaccharide, count) pairs
        '''
        pattern = re.compile(
            r'''(?P<monosacch>[A-z0-9]*)(?P<count>\([A-z0-9]*\))''' )
        glycan_dict = {}
        for glyc_match in pattern.finditer(glycan):
            monosacch = glyc_match.group('monosacch')
            if monosacch == 'End':
                count = glyc_match.group('count').strip('(').strip(')')
                if count == 'None':
                    count = None
            elif glyc_match.group('count') == '':
                count = 1
            else:
                count = int(glyc_match.group('count').strip('(').strip(')'))
            glycan_dict[monosacch] = count
        sp_tuple = tuple(sorted(glycan_dict.items()))
        return sp_tuple

    def sort_plot_lists(
        self,
        name_list=None,
        x_axis_list=None,
        y_axis_list=None,
        text_list=None
    ):
        '''
        Sort name_list alphabetically in a new list and append elements from
        x_axis_list, y_axis_list and text_list to new sorted lists in the right
        order.
        '''
        # import pprint
        # pprint.pprint(name_list)
        # print("_____________________________")
        # pprint.pprint(text_list)
        # exit()
        sorted_name_list = sorted(name_list)
        sorted_x_axis_list = []
        sorted_y_axis_list = []
        sorted_text_list = []
        for peptide in sorted_name_list:
            index = name_list.index(peptide)
            sorted_x_axis_list.append(x_axis_list[index])
            sorted_y_axis_list.append(y_axis_list[index])
            sorted_text_list.append(text_list[index])
        return sorted_name_list, sorted_x_axis_list, sorted_y_axis_list, sorted_text_list

    def plot_scatter_vec_id(
        self,
        x_axis_list=None,
        y_axis_list=None,
        text_list=None,
        name_list=None,
        title=None,
        x_axis_name=None,
        y_axis_name=None,
        output_file=None,
        plotly_layout=None,
    ):
        '''
        Plots a Scatter plot with given x and y data. Both need to be given
        as a list of lists, each list representing one trace in the final plot.
        Values can be annotated using a text_list.
        Traces can be annotated using a name_list.
        '''

        # trace_colors=[
        #     '#e6194b',
        #     '#3cb44b',
        #     '#ffe119',
        #     '#4363d8',
        #     '#f58231',
        #     '#911eb4',
        #     '#46f0f0',
        #     '#f032e6',
        #     '#bcf60c',
        #     '#fabebe',
        #     '#008080',
        #     '#e6beff',
        #     '#9a6324',
        #     '#fffac8',
        #     '#800000',
        #     '#aaffc3',
        #     '#808000',
        #     '#ffd8b1',
        #     '#000075',
        #     '#808080',
        #     '#000000',
        #     # '#ffffff',
        # ]
        trace_colors = [
            'rgb(77,175,74)',
            'rgb(228,26,28)',
            'rgb(55,126,184)',
            'rgb(152,78,163)',
            'rgb(166,86,40)',
            'rgb(255,127,0)',
            # 'rgb(255,255,51)',
            'rgb(247,129,191)',
            'rgb(102,194,165)',
            'rgb(252,141,98)',
            'rgb(141,160,203)',
            # 'rgb(231,138,195)',
            'rgb(166,216,84)',
            'rgb(255,217,47)',
            # 'rgb(229,196,148)',
            # 'rgb(179,179,179)',
            'rgb(166,118,29)',
            'rgb(27,158,119)',
            'rgb(102,102,102)',
        ]
        trace_markers = [
            'circle',
            'square',
            'diamond',
            'triangle-up',
            'triangle-down',
            'star',
        ]
        data = []
        for trace, x_axis in enumerate(x_axis_list):
            marker_n = 0
            for x in range(0,100):
                if trace >= x*len(trace_colors) and trace < (x+1)*len(trace_colors):
                    trace_color_n = trace - x*len(trace_colors)
                    marker_n = x
            trace0 = go.Scatter(
                x=x_axis,
                y=y_axis_list[trace],
                mode='lines+markers',
                marker=dict(
                    color=trace_colors[trace_color_n],
                    size=7,
                    line=dict(
                        width=0.3,
                        color='rgb(0,0,0)'
                    ),
                    symbol=trace_markers[marker_n],
                ),
                name=name_list[trace],
                text=text_list[trace],
                # visible='legendonly',
            )
            data.append(trace0)

        layout = go.Layout(
            title=title,
            hovermode='closest',
            xaxis1=dict(
                title=x_axis_name,
                ticklen=5,
                # zeroline=False,
                # gridwidth=2,
            ),
            yaxis1=dict(
                title=y_axis_name,
                ticklen=5,
                # gridwidth=2,
            ),
            autosize=False,
            width=1700,
            height=500 + 30 * len(name_list),
        )
        layout.update(**plotly_layout)
        fig = go.Figure(data=data, layout=layout)
        # plotly.offline.plot(
        #     fig,
        #     filename=output_file,
        #     auto_open=False
        # )
        plotly.io.write_html(fig, output_file)
        plotly.io.write_image(fig, output_file.replace('.html', '.pdf'))
        return output_file

    def plot_annotated_spectra(
        self,
        mzml_file=None,
        plot_peak_types=[
            'matched',
            'unmatched',
            'labels',
        ],
        remove_subtrees=[],
        plot_molecule_dict=None,
        peak_colors={
            'matched': (0, 200, 0),
            'unmatched': (200, 0, 0),
            'labels': (0, 0, 200),
            'raw': (100, 100, 100),
        },
        ms_level=1,
        output_folder='',
        ms_precision='5e-6',
        plotly_layout=None,
    ):
        '''
        Plot one or multiple spectra (raw data).
        The following peaks can be added:

        * matched (peaks matched by pyQms) and/or
        * unmatched (unmatched peaks from matched formulas) peaks
        * labels (for monoisotopic peaks)
        
        '''
        created_plots = []
        if plot_molecule_dict is None or plot_molecule_dict == {}:
            print('[ SugarPy  ] Nothing to plot here (plot_spectrum)')
            print('[ SugarPy  ] for file:', output_file)
            return created_plots

        for peptide_unimod in sorted(self.keys()):
            scored_glycans = self[peptide_unimod]['scored_glycans']
            spec_collector = self[peptide_unimod]['spec_collector']
            if peptide_unimod not in plot_molecule_dict.keys():
                continue
            results_dict = {}
            for glycan in plot_molecule_dict[peptide_unimod].keys():
                for i, file_name in enumerate(plot_molecule_dict[peptide_unimod][glycan]['file_names']):
                    if file_name not in mzml_file:
                        continue
                    spec = plot_molecule_dict[
                        peptide_unimod][glycan]['specs'][i]
                    charges = plot_molecule_dict[
                        peptide_unimod][glycan]['charges'][i]
                    if spec not in results_dict.keys():
                        results_dict[spec] = {}
                    results_dict[spec][glycan] = charges

            pep_name = '-'.join(peptide_unimod.split(';'))
            pep_name = '_'.join(peptide_unimod.split(':'))
            mzml_basename = os.path.basename(mzml_file).replace('.mzML', '')
            raw_peaks = {}
            run = pymzml.run.Reader(
                mzml_file,
                # extraAccessions=[
                #     ('MS:1000016', ['value', 'unitName'])
                # ],
                # obo_version='1.1.0'
            )
            for n, spectrum in enumerate(run):
                if spectrum.ms_level == ms_level:
                    spec_id = spectrum.ID
                    if spectrum.ID not in results_dict.keys():
                        continue
                    raw_peaks[spectrum.ID] = spectrum.peaks('centroided')
                else:
                    continue

            for spec in sorted(results_dict.keys()):
                pf = Factory()
                pf.new_plot(
                    MS_precision=ms_precision
                )
                pf.add(
                    raw_peaks[spec],
                    color=eval(peak_colors['raw'].strip('rgb')),
                    style='sticks',
                    name='Raw data',
                )
                for glycan in results_dict[spec].keys():
                    sp_tuple = self.glycan_to_tuple(glycan)
                    unmatched_peaks = []
                    matched_peaks = []
                    label_list = []
                    if 'unmatched' in plot_peak_types or 'matched' in plot_peak_types:
                        scored_glycan_dict = scored_glycans[spec][sp_tuple]
                        formula_list = scored_glycan_dict['subtrees']
                        for formula in formula_list:
                            if formula in remove_subtrees:
                                continue
                            charges = spec_collector[spec][formula]['charge']
                            # if plot_all_charges == True:
                            #     charges = spec_collector[spec][formula]['charge']
                            # else:
                            #     charges = results_dict[spec][sp_tuple]
                            for charge_i, charge in enumerate(charges):
                                # charge = int(charge)
                                # if charge not in spec_collector[spec][formula]['charge']:
                                #     continue
                                # charge_i = spec_collector[spec][
                                #     formula]['charge'].index(charge)
                                scaling_factor = spec_collector[spec][formula][
                                    'vector'][charge_i]['scaling_factor']
                                peaks = spec_collector[spec][formula][
                                    'vector'][charge_i]['peaks']
                                add_label = True
                                for mmz, mi, ri, cmz, ci in peaks:
                                    if mmz is None:
                                        unmatched_peaks.append(
                                            (cmz, scaling_factor * ci))
                                        continue
                                    # raw_peaks.append( (mmz, mi) )
                                    matched_peaks.append(
                                        (cmz, scaling_factor * ci))
                                    # matched_peaks.append( ( mmz, mi ) )
                                    if add_label is False:
                                        continue
                                    label = ''
                                    for trivial_name in spec_collector[spec][formula]['trivial_name'][0]:
                                        if '|' in trivial_name:
                                            label += 'P+{0} z={1}<br>'.format(
                                                trivial_name.split('|')[1],
                                                charge
                                            )
                                        else:
                                            label += 'P z={0}<br>'.format(
                                                charge
                                            )
                                    label_list.append((
                                        cmz,
                                        'max_intensity',
                                        label
                                    ))
                                    add_label = False

                    if 'matched' in plot_peak_types:
                        pf.add(
                            matched_peaks,
                            color=eval(peak_colors['matched'].strip('rgb')),
                            style='triangle.MS_precision',
                            name='Matched Peaks {0}'.format(glycan)
                        )
                    if 'unmatched' in plot_peak_types:
                        pf.add(
                            unmatched_peaks,
                            color=eval(peak_colors['unmatched'].strip('rgb')),
                            style='triangle.MS_precision',
                            name='Unmatched Peaks {0}'.format(glycan)
                        )
                    if 'labels' in plot_peak_types:
                        pf.add(
                            label_list,
                            color=eval(peak_colors['labels'].strip('rgb')),
                            style='label.sticks',
                            dash='dash',
                            name='Label',
                        )
                output_file_name = '{0}_{1}_{2}.html'.format(
                    os.path.join(
                        output_folder,
                        os.path.basename(mzml_file).replace('.mzML', ''),
                    ),
                    pep_name,
                    spec
                )
                pf.save(output_file_name, layout=plotly_layout)
                print('plotted spec:', output_file_name)
                created_plots.append(output_file_name)
        print('[ SugarPy  ] Plotted annotated spectrum:', output_file_name)
        return created_plots

    def check_peak_presence(
        self,
        mzml_file=None,
        sp_result_file=None,
        ms_level=1,
        output_file='',
        pyqms_params=None,
        rt_border_tolerance=None,
        min_spec_number=1,
        charges=[1, 2, 3, 4, 5]
    ):
        '''
        Takes a SugarPy result file as well as an mzML file
        to check in the mzML file for the presence of peaks
        corresponding to identified glycopeptides.
        If any are found, it is also checked if they were 
        fragmented at some point of the run.
        '''
        print('[ SugarPy  ] Parsing SugarPy result file:', sp_result_file)
        internal_precision = pyqms_params['INTERNAL_PRECISION']
        ms_precision = pyqms_params['REL_MZ_RANGE']

        formula_to_rt, molecule_name_dict, rt_list, line_dict_list, csv_fieldnames, molecule_spec_count, peak_presence_dict = self.parse_result_file(
            sp_result_file,
            return_type='peak_presence',
            min_spec_number=1
        )

        print('[ SugarPy  ] Checking presence of intact glycopeptide elution peaks,')
        print('[ SugarPy  ] and if they have been triggered for fragmentation')
        sp_run = sugarpy.run.Run()
        results_pkl, precursor_to_rt_id, lib = sp_run.quantify(
            molecule_name_dict=molecule_name_dict,
            rt_window=(
                min(rt_list)-rt_border_tolerance,
                max(rt_list)+rt_border_tolerance
            ),
            ms_level=ms_level,
            charges=charges,  # sorted(charge_set),
            params=pyqms_params,
            pkl_name=mzml_file.replace('.mzML', '_check_peaks.pkl'),
            mzml_file=mzml_file,
            collect_precursor=True,
        )

        precursor_tmz_to_rt_id = {}
        for precursor in precursor_to_rt_id.keys():
            precursor_tmz = int(round(precursor * internal_precision))
            if precursor_tmz not in precursor_tmz_to_rt_id.keys():
                precursor_tmz_to_rt_id[precursor_tmz] = []
            precursor_tmz_to_rt_id[precursor_tmz].extend(
                precursor_to_rt_id[precursor]
            )
        # sugarpy_tmz_set = set()
        glycopep_tmz_with_error = ddict(list)
        for formula in molecule_name_dict.keys():
            for charge in range(1, 6):
                for n, iso_mz in enumerate(
                    lib[formula]['env'][(('N', '0.000'),)][charge]['mz'][:3]
                ):
                    # if n == 0:
                    #     sugarpy_tmz_set.addint(round(iso_mz * internal_precision))
                    for t_mz_with_error in range(
                            int(round((iso_mz - (iso_mz * ms_precision))
                                      * internal_precision)),
                            int(round((iso_mz + (iso_mz * ms_precision)) * internal_precision)) + 1):
                        glycopep_tmz_with_error[
                            t_mz_with_error].append(formula)
        selected_glycopeps = {}
        precursor_tmz_set = set(precursor_tmz_to_rt_id.keys())
        glyco_tmz_error_set = set(glycopep_tmz_with_error.keys())
        for selected_tmz in precursor_tmz_set & glyco_tmz_error_set:
            formula_list = glycopep_tmz_with_error[selected_tmz]
            for formula in formula_list:
                if formula not in selected_glycopeps:
                    selected_glycopeps[formula] = []
                rt_id = precursor_tmz_to_rt_id[selected_tmz]
                selected_glycopeps[formula].extend(rt_id)

        formula_to_matchspec = {}
        with open(results_pkl, 'rb') as open_pkl:
            results = pickle.load(open_pkl)
            for m_key, results_value in results.items():
                formula = m_key.formula
                trivial_name = results.lookup[
                    'formula to trivial name'][formula][0]
                for matched_spectrum in results_value['data']:
                    mscore = matched_spectrum.score
                    rt = matched_spectrum.rt
                    spec_id = matched_spectrum.spec_id
                    if rt >= min(formula_to_rt[formula]) - rt_border_tolerance and\
                            rt <= max(formula_to_rt[formula]) + rt_border_tolerance:
                        if formula not in formula_to_matchspec.keys():
                            formula_to_matchspec[formula] = []
                        formula_to_matchspec[formula].append(str(spec_id))

        ms1_new_fieldname = '{0} MS1 Spectrum IDs (without IS-CID)'.format(
            os.path.basename(mzml_file).replace('.mzML', '')
        )
        ms2_new_fieldname = '{0} MS2 Spectrum IDs (without IS-CID)'.format(
            os.path.basename(mzml_file).replace('.mzML', '')
        )
        csv_fieldnames.extend([
            'MS1 Peaks Present',
            ms1_new_fieldname,
            'MS1 Selected for Fragmentation',
            ms2_new_fieldname
        ])
        output_file_name = sp_result_file.replace('.csv', '_peak_presence.csv')
        opened_output_file = open(output_file_name, 'w')
        if sys.platform == 'win32':
            lineterminator = '\n'
        else:
            lineterminator = '\r\n'
        csv_writer = csv.DictWriter(
            opened_output_file, csv_fieldnames, lineterminator=lineterminator)
        csv_writer.writeheader()

        # fragmented_peaks_in_window = {}
        formulas_with_peak = set()
        formulas_fragmented = set()
        for line_dict in line_dict_list:
            formula = line_dict['Chemical Formula']
            if formula not in formula_to_matchspec.keys():
                line_dict[ms1_new_fieldname] = ''
                line_dict['MS1 Peaks Present'] = 'False'
            elif len(formula_to_matchspec[formula]) >= min_spec_number:
                line_dict[ms1_new_fieldname] = ';'.join(
                    sorted(formula_to_matchspec[formula])
                )
                line_dict['MS1 Peaks Present'] = 'True'
                formulas_with_peak.add(formula)
            if formula in selected_glycopeps.keys():
                frag_spec_ids = []
                for rt, spec_id in selected_glycopeps[formula]:
                    if rt >= min(formula_to_rt[formula]) - rt_border_tolerance and\
                            rt <= max(formula_to_rt[formula]) + rt_border_tolerance:
                        frag_spec_ids.append(str(spec_id))
                        formulas_fragmented.add(formula)
                        # if formula not in fragmented_peaks_in_window.keys():
                        #     fragmented_peaks_in_window[formula] = []
                        # fragmented_peaks_in_window[formula].append(spec_id)
                line_dict[ms2_new_fieldname] = ';'.join(
                    sorted(frag_spec_ids)
                )
                if len(frag_spec_ids) > 0:
                    line_dict['MS1 Selected for Fragmentation'] = 'True'
                else:
                    line_dict['MS1 Selected for Fragmentation'] = 'False'
            csv_writer.writerow(line_dict)
        opened_output_file.close()
        print('[ SugarPy  ] Updated SugarPy results file: ', output_file_name)

        sugarpy_formulas = set(molecule_name_dict.keys())

        venn_data = [
            {
                'label': 'SugarPy identifications',
                'data' : sugarpy_formulas,
            },
            {
                'label': 'MS1 Peaks',
                'data' : formulas_with_peak,
            },
            {
                'label': 'Fragmented for MS2',
                'data' : formulas_fragmented,
            }
        ]

        # peak_presence_dict = {}
        # for formula in molecule_name_dict.keys():
        #     peak_presence_dict[formula] = {
        #         'name_list' : sorted(molecule_name_dict[formula]),
        #         'ms1_peak_specs' : [],
        #         'ms2_frag_specs' : [],
        #     }
        #     if formula in fragmented_peaks_in_window.keys():
        #         peak_presence_dict[formula][
        #             'ms2_frag_specs'] = fragmented_peaks_in_window[formula]
        #     if formula in formula_to_matchspec.keys():
        #         peak_presence_dict[formula]['ms1_peak_specs'] = [
        #             int(s) for s in formula_to_matchspec[formula]
        #         ]

        return output_file_name, venn_data

    def check_frag_specs(
        self,
        mzml_file=None,
        ursgal_ident_file=None,
        sp_result_file=None,
        # peak_presence_dict=None,
        frag_mass_tolerance=None,
        decoy_glycan='End(HexNAc)Hex(5)HexNAc(3)NeuAc(1)dHex(1)',
        glycans_incl_in_search=[],
        # max_tree_length=10,
        min_oxonium_ions=3,
        min_Y_ions=1,
        output_file=None,
        pyqms_params=None,
    ):
        internal_precision = pyqms_params['INTERNAL_PRECISION']
        print('[ SugarPy  ] Checking presence of glycopeptide fragment ions ...')
        if mzml_file.endswith('idx.gz') is False:
            indexed_mzml = mzml_file + '.idx.gz'
            if os.path.exists(indexed_mzml):
                pass
            else:
                from pymzml.utils.utils import index_gzip
                with open(mzml_file) as fin:
                    fin.seek(0, 2)
                    max_offset_len = fin.tell()
                    max_spec_no = pymzml.run.Reader(
                        mzml_file).get_spectrum_count() + 10
                index_gzip(
                    mzml_file,
                    indexed_mzml,
                    max_idx=max_spec_no,
                    idx_len=len(str(max_offset_len))
                )
        else:
            indexed_mzml = mzml_file
        pymzml_run = pymzml.run.Reader(
            indexed_mzml,
            MSn_Precision=frag_mass_tolerance * 1e-6
        )
        ms2_new_fieldname = '{0} MS2 Spectrum IDs (without IS-CID)'.format(
            os.path.basename(mzml_file).replace('.mzML', '')
        )

        sp_run = sugarpy.run.Run()
        # parse Ursgal ident file to create a peptide lookup
        ursgal_peptide_lookup = sp_run.parse_ident_file(
            ident_file=ursgal_ident_file,
            unimod_glycans_incl_in_search=[],
        )

        if sys.platform == 'win32':
            lineterminator = '\n'
        else:
            lineterminator = '\r\n'

        if decoy_glycan != 'None':
            # For each peptide, check if the corresponding ident spectra contain oxonium and/or Y-ions.
            # Spectra of peptides harboring glycans included in glycans_incl_in_search
            # will be searched for corresponding fragment ions.
            # Other spectra will be searched for fragment ions of a decoy glycan, 
            # this provides an idea for how often fragment ions match by chance (potential false positives)
            ursgal_pep_to_frag_ions = {}
            peps_no_glycan = set()
            peps_with_glycan = set()
            mod_pattern = re.compile( r''':(?P<pos>[0-9]*$)''' )
            for peptide_unimod in ursgal_peptide_lookup.keys():
                ursgal_pep_to_frag_ions[peptide_unimod] = {}
                all_glycans_from_peptide = []
                non_glycan_unimods = []
                if '#' in peptide_unimod:
                    peptide, modifications = peptide_unimod.split('#')
                else:
                    peptide = peptide_unimod
                    modifications = ''
                mod_list = modifications.split(';')
                for mod in mod_list:
                    match = mod_pattern.search(mod)
                    if match is None:
                        continue
                    mod_name = mod[:match.start()]
                    mod_pos = mod[match.start()+1:]
                    if mod_name in glycans_incl_in_search:
                        all_glycans_from_peptide.append(mod)
                    else:
                        non_glycan_unimods.append(mod)
                if len(non_glycan_unimods) == 0:
                    pep_without_glycans = peptide
                else:
                    pep_without_glycans = '{0}#{1}'.format(
                        peptide,
                        ';'.join(non_glycan_unimods)
                    )
                spec_id_list = ursgal_peptide_lookup[peptide_unimod]['spec_id']
                if len(all_glycans_from_peptide) == 0:
                    assert pep_without_glycans == peptide_unimod, '''
                    [ ERROR ] peptide_unimod was changed but list all_glycans_from_peptide is empty
                    {0}
                    {1}
                    '''.format(pep_without_glycans, peptide_unimod)
                    glycan_list = [decoy_glycan]
                    peps_no_glycan.add(peptide_unimod)
                else:
                    glycan_list = all_glycans_from_peptide
                    peps_with_glycan.add(peptide_unimod)
                spec_to_frag_ions = self.calc_and_match_frag_ions(
                    pymzml_run=pymzml_run,
                    glycan_list=glycan_list,
                    peptide_unimod=pep_without_glycans,
                    spec_id_list=spec_id_list,
                    # max_tree_length=max_tree_length,
                    internal_precision=internal_precision,
                )
                for spec_id in spec_to_frag_ions.keys():
                    ursgal_pep_to_frag_ions[peptide_unimod][
                        spec_id] = spec_to_frag_ions[spec_id]

            # info about oxonium and Y-ions is added to the Ursgal ident file
            targets_with_frag_ions = set()
            decoys_with_frag_ions = set()
            ursgal_output_file = ursgal_ident_file.replace(
                '.csv', '_glycofrag_ions.csv'
            )

            with open(ursgal_ident_file, 'r') as u_in_file:
                csv_input = csv.DictReader(u_in_file)
                csv_fieldnames = csv_input.fieldnames
                csv_fieldnames.extend([
                    'Oxonium Ions',
                    'Glycopeptide Y-ions',
                ])
                with open(ursgal_output_file, 'w') as u_out_file:
                    csv_writer = csv.DictWriter(
                        u_out_file, csv_fieldnames, lineterminator=lineterminator)
                    csv_writer.writeheader()
                    for line_dict in csv_input:
                        has_oxonium_ions = False
                        has_Y_ions = False
                        if line_dict['Modifications'] == '':
                            peptide_unimod = line_dict['Sequence']
                        else:
                            peptide_unimod = '{0}#{1}'.format(
                                line_dict['Sequence'],
                                line_dict['Modifications']
                            )
                        spec_id = int(line_dict['Spectrum ID'])
                        # line_dict['Oxonium Ions'] = ''
                        # line_dict['Glycopeptide Y-ions'] = ''
                        if ursgal_pep_to_frag_ions[peptide_unimod] == {}:
                            csv_writer.writerow(line_dict)
                            continue
                        Y_ions = ursgal_pep_to_frag_ions[peptide_unimod][spec_id]['Y_ions']
                        if len(Y_ions) >= min_Y_ions:
                            line_dict['Glycopeptide Y-ions'] = ';'.join(Y_ions)
                            for obligatory in [
                                'HexNAc(1)',
                                'HexNAc(1)-H2O(1)',
                                # 'HexNAc(2)',
                                # 'HexNAc(2)-H2O(1)',
                                # 'HexNAc(2)-H2O(2)'
                            ]:
                                if obligatory in Y_ions:
                                    has_Y_ions = True
                        oxonium_ions = ursgal_pep_to_frag_ions[peptide_unimod][spec_id]['oxonium_ions']
                        if len(oxonium_ions) >= min_oxonium_ions:
                            line_dict['Oxonium Ions'] = ';'.join(oxonium_ions)
                            has_oxonium_ions = True
                        csv_writer.writerow(line_dict)
                        if has_Y_ions and has_oxonium_ions:
                            if peptide_unimod in peps_with_glycan:
                                targets_with_frag_ions.add(peptide_unimod)
                            else:
                                decoys_with_frag_ions.add(peptide_unimod)
                                # print('FP!?:', peptide_unimod, spec_id)
            print('[ SugarPy  ] Updated Ursgal results file: ', ursgal_output_file)

            # Venn diagram for potential false positives is generated in wrapper,
            # passing down values here
            venn_data_false_pos = [
                {
                    'label': 'Ursgal Peptides',
                    'data' : set(ursgal_pep_to_frag_ions.keys()),
                },
                {
                    'label': 'Peptides w/ Decoy Glyco Fragment Ions',
                    'data' : decoys_with_frag_ions,
                },
                {
                    'label': 'Peptides w/ Target Glyco Fragment Ions',
                    'data' : targets_with_frag_ions,
                },
            ]

        formula_to_rt, molecule_name_dict, rt_list, line_dict_list, csv_fieldnames, molecule_spec_count, peak_presence_dict = self.parse_result_file(
            sp_result_file,
            return_type='peak_presence',
        )
        if peak_presence_dict is None:
            sugarpy_output_file = None
            venn_data_sp_frag = None
            return ursgal_output_file, venn_data_false_pos, sugarpy_output_file, venn_data_sp_frag

        # For all glycopeptides, identified by IS-CID, that show MS1 peaks in a run without IS-CID,
        # corresponding fragmentation spectra are checked for oxonium and Y-ions
        sugarpy_formula_to_frag_ions = {}
        for n, formula in enumerate(sorted(peak_presence_dict.keys())):
            print(
                '[ SugarPy  ] Checking formula {0} out of {1}    '.format(
                    n,
                    len(peak_presence_dict.keys())
                ),
                end='\r'
            )
            sugarpy_formula_to_frag_ions[formula] = {}
            glycopep_list = peak_presence_dict[formula]['name_list']
            for glycopep in set(glycopep_list):
                sugarpy_formula_to_frag_ions[formula][glycopep] = {}
                peptide, unimod, glycan = glycopep.split('#')
                peptide_unimod = '{0}#{1}'.format(
                    peptide,
                    unimod
                )
                spec_to_frag_ions = self.calc_and_match_frag_ions(
                    pymzml_run=pymzml_run,
                    glycan_list=[glycan],
                    peptide_unimod=peptide_unimod,
                    spec_id_list=sorted(peak_presence_dict[
                        formula]['ms2_frag_specs']),
                    # max_tree_length=max_tree_length,
                    internal_precision=internal_precision,
                )
                for spec_id in spec_to_frag_ions.keys():
                    sugarpy_formula_to_frag_ions[formula][glycopep][
                        spec_id] = spec_to_frag_ions[spec_id]

        # info about oxonium and Y-ions is added to the sugarpy result file
        all_glycopeps = set()
        all_fragmented_glycopeps = set()
        glycopeps_with_frag_ions = set()
        sugarpy_output_file = sp_result_file.replace(
            '.csv', '_glycofrag_ions.csv'
        )
        with open(sp_result_file, 'r') as sp_in_file:
            csv_input = csv.DictReader(sp_in_file)
            csv_fieldnames = csv_input.fieldnames
            y_ion_new_fieldname = '{0} Glycopeptide Y-ions'.format(
                os.path.basename(mzml_file).replace('.mzML', '')
            )
            ox_ion_new_fieldname = '{0} Oxonium Ions'.format(
                os.path.basename(mzml_file).replace('.mzML', '')
            )
            csv_fieldnames.extend([
                'MS2 Frag Ions Present',
                ox_ion_new_fieldname,
                y_ion_new_fieldname,
            ])
            with open(sugarpy_output_file, 'w') as sp_out_file:
                csv_writer = csv.DictWriter(
                    sp_out_file, csv_fieldnames, lineterminator=lineterminator)
                csv_writer.writeheader()
                for line_dict in csv_input:
                    glycopep = '{0}#{1}#{2}'.format(
                        line_dict['Sequence'],
                        line_dict['Modifications'],
                        line_dict['Glycan']
                    )
                    all_glycopeps.add(glycopep)
                    formula = line_dict['Chemical Formula']
                    spec_id_list = line_dict[ms2_new_fieldname].split(';')
                    if spec_id_list == [''] or spec_id_list == []:
                        csv_writer.writerow(line_dict)
                        continue
                    all_fragmented_glycopeps.add(glycopep)
                    Y_ions = []
                    oxonium_ions = []
                    true_glycopep = False
                    for spec_id in spec_id_list:
                        has_oxonium_ions = False
                        has_Y_ions = False
                        spec_id = int(spec_id)
                        sugarpy_Y_ions = sugarpy_formula_to_frag_ions[formula][glycopep][spec_id]['Y_ions']
                        if len(sugarpy_Y_ions) >= min_Y_ions:
                            for obligatory in [
                                'HexNAc(1)',
                                'HexNAc(1)-H2O(1)',
                                # 'HexNAc(2)',
                                # 'HexNAc(2)-H2O(1)',
                                # 'HexNAc(2)-H2O(2)'
                            ]:
                                if obligatory in sugarpy_Y_ions:
                                    has_Y_ions = True
                        Y_ions.append(
                            [';'.join(sugarpy_Y_ions)]
                            )
                        sugarpy_ox_ions = sugarpy_formula_to_frag_ions[formula][glycopep][spec_id]['oxonium_ions']
                        if len(sugarpy_ox_ions) >= min_oxonium_ions:
                            has_oxonium_ions = True
                        oxonium_ions.append(
                            [';'.join(sugarpy_ox_ions)]
                            )
                        if has_Y_ions and has_oxonium_ions:
                            glycopeps_with_frag_ions.add(glycopep)
                            true_glycopep = True

                    if true_glycopep:
                        line_dict['MS2 Frag Ions Present'] = True
                    else:
                        line_dict['MS2 Frag Ions Present'] = False

                    y_ions_string = ''
                    for y in Y_ions:
                        y_ions_string += '{0};'.format(y)
                    line_dict[y_ion_new_fieldname] = y_ions_string.strip(';')
                    ox_ions_string = ''
                    for o in oxonium_ions:
                        ox_ions_string += '{0};'.format(o)
                    line_dict[ox_ion_new_fieldname] = ox_ions_string.strip(';')
                    csv_writer.writerow(line_dict)

        print('[ SugarPy  ] Updated SugarPy results file: ', sugarpy_output_file)

        venn_data_sp_frag = [
            {
                'label': 'SugarPy Glycopeptides',
                'data' : all_glycopeps,
            },
            {
                'label': 'Fragmented Glycopeptides',
                'data' : all_fragmented_glycopeps,
            },
            {
                'label': 'Glycopeptides with Glyco Fragment Ions',
                'data' : glycopeps_with_frag_ions,
            },
        ]

        if decoy_glycan == 'None':
            ursgal_output_file = ursgal_ident_file
            venn_data_false_pos = None

        return ursgal_output_file, venn_data_false_pos, sugarpy_output_file, venn_data_sp_frag

    def calc_and_match_frag_ions(
        self,
        glycan_list=[],
        peptide_unimod=None,
        spec_id_list=[],
        pymzml_run=None,
        # max_tree_length=10,
        internal_precision=None,
    ):
        '''
        Returns:
            dict: {spec_id: {'oxonium_ions' : [], 'Y_ions' : [],}}
        '''
        combined_calculated_oxonium_ions = {}
        combined_y_list = []
        for glycan in glycan_list:
            glycan_as_list = []
            end_monosacch = None
            glycan_tuple = self.glycan_to_tuple(glycan)
            for monosacch, amount in glycan_tuple:
                if monosacch == 'End':
                    if end_monosacch is not None\
                        and end_monosacch != amount:
                        print('[ERROR] Multiple different end monosaccharides')
                        sys.exit(1)
                    end_monosacch = amount
                    continue
                glycan_as_list.extend([monosacch] * amount)
                combined_y_list.extend([monosacch] * amount)
            sp_run = sugarpy.run.Run()
            glycan_combinations = sp_run.build_combinations(
                max_tree_length=len(glycan_as_list),
                monosaccharides=glycan_as_list,
                mode='combinations',
            )
            # import pprint
            # pprint.pprint(glycan)
            calculated_oxonium_ions = self.calc_oxonium_ions(
                glycan_combinations=glycan_combinations,
                internal_precision=internal_precision,
            )
            for k, v in calculated_oxonium_ions.items():
                if k not in combined_calculated_oxonium_ions.keys():
                    combined_calculated_oxonium_ions[k] = set()
                combined_calculated_oxonium_ions[k] |= v
        spec_to_frag_ions = {}
        for spec_id in spec_id_list:
            spec_to_frag_ions[spec_id] = {
                'oxonium_ions' : [],
                'Y_ions' : [],
            }
            spectrum = pymzml_run[spec_id]
            selected_precursors = spectrum.selected_precursors
            if selected_precursors != [] and 'charge' in selected_precursors[0]:
                charge = selected_precursors[0]['charge']
            else:
                print('''
                    [ Warning ] Charge of precursor could not be determined.
                    [ Warning ] Working with charge = 2
                ''')
                charge = 2
            oxonium_ion_tmz_set = set(combined_calculated_oxonium_ions.keys())
            spec_tmz_set = spectrum.t_mz_set
            matching_tmz = oxonium_ion_tmz_set & spec_tmz_set
            for oxonium_ion_tmz in matching_tmz:
                oxonium_ion_names = combined_calculated_oxonium_ions[
                    oxonium_ion_tmz]
                spec_to_frag_ions[spec_id]['oxonium_ions'].append(
                    '|'.join(sorted(oxonium_ion_names))
                )
            glycan_combinations = sp_run.build_combinations(
                max_tree_length=len(combined_y_list),
                monosaccharides=combined_y_list,
                mode='combinations',
            )
            calculated_Y_ions = self.calc_Y_ions(
                glycan_combinations=glycan_combinations,
                peptide_unimod=peptide_unimod,
                charge=charge,
                end_monosacch=end_monosacch,
                internal_precision=internal_precision,
            )
            Y_ion_tmz_set = set(calculated_Y_ions.keys())
            matching_tmz = Y_ion_tmz_set & spec_tmz_set
            for Y_ion_tmz in matching_tmz:
                Y_ion_name_list = calculated_Y_ions[Y_ion_tmz]
                spec_to_frag_ions[spec_id]['Y_ions'].append(
                    '|'.join(Y_ion_name_list)
                )

        return spec_to_frag_ions

    def calc_oxonium_ions(
        self,
        glycan_combinations=None,
        internal_precision=None
    ):
        '''
        Returns:
            dict: { transformed mz for z=1 : [name1, name2, ...] }
        '''
        oxonium_ions = {}
        for length in glycan_combinations.keys():
            for glycan_dict in glycan_combinations[length]:
                name_hill = ''
                for monosacch in sorted(glycan_dict.keys()):
                    name_hill += '{0}({1})'.format(
                        monosacch,
                        glycan_dict[monosacch]
                    )
                cc = ursgal.ChemicalComposition()
                cc.add_glycan(name_hill)
                # cc.add_chemical_formula('H(1)')
                mz = ursgal.ucore.calculate_mz(cc._mass(), 1)
                tmz = int(round(mz * internal_precision))
                if tmz not in oxonium_ions.keys():
                    oxonium_ions[tmz] = set()
                oxonium_ions[tmz].add(name_hill)
                if length == 1:
                    continue
                for water_loss_count in [1]: #[1, 2]:
                    new_name_hill = name_hill + '-H2O({0})'.format(
                        water_loss_count
                    )
                    cc.subtract_chemical_formula(
                        'H(2)O(1)',
                        factor=water_loss_count
                    )
                    mz = ursgal.ucore.calculate_mz(cc._mass(), 1)
                    tmz = int(round(mz * internal_precision))
                    if tmz not in oxonium_ions.keys():
                        oxonium_ions[tmz] = set()
                    oxonium_ions[tmz].add(new_name_hill)
                    cc.add_chemical_formula(
                        'H(2)O(1)',
                        factor=water_loss_count
                    )

        return oxonium_ions

    def calc_Y_ions(
        self,
        glycan_combinations=None,
        peptide_unimod=None,
        charge=2,
        end_monosacch='HexNAx',
        internal_precision=None,
    ):
        '''
        Returns:
            dict: { transformed mz: [name1, name2, ...] }
        '''
        Y_ions = {}
        cc = ursgal.ChemicalComposition()
        for length in glycan_combinations.keys():
            for glycan_dict in glycan_combinations[length]:
                cc.use(peptide_unimod)
                if end_monosacch is not None and end_monosacch not in glycan_dict.keys():
                    continue
                name_hill = ''
                for monosacch in sorted(glycan_dict.keys()):
                    name_hill += '{0}({1})'.format(
                        monosacch,
                        glycan_dict[monosacch]
                    )
                cc.add_glycan(name_hill)
                for z in range(1, charge + 1):
                    mz = ursgal.ucore.calculate_mz(cc._mass(), z)
                    tmz = int(round(mz * internal_precision))
                    # print(z, peptide_unimod, mz, name_hill)
                    if tmz not in Y_ions.keys():
                        Y_ions[tmz] = []
                    Y_ions[tmz].append(name_hill)
                    for water_loss_count in [1, 2]:
                        new_name_hill = name_hill + '-H2O({0})'.format(
                            water_loss_count
                        )
                        cc.subtract_chemical_formula(
                            'H(2)O(1)',
                            factor=water_loss_count
                        )
                        mz = ursgal.ucore.calculate_mz(cc._mass(), z)
                        tmz = int(round(mz * internal_precision))
                        if tmz not in Y_ions.keys():
                            Y_ions[tmz] = []
                        Y_ions[tmz].append(new_name_hill)
                        cc.add_chemical_formula(
                            'H(2)O(1)',
                            factor=water_loss_count
                        )
        return Y_ions

    def extract_best_matches(
        self,
        sp_result_file=None,
        output_file='extracted_results.csv',
        max_trees_per_spec=1,
        min_spec_number=1,
    ):
        '''
        Filter a SugarPy results csv file to extract the best matching glycan compositions.

        Keyword Arguments:
            sp_result_file (str): inpput file path
            output_file: output file name
            max_trees_per_spec:
                Maximum number of glycan compositions taken into account per spectrum
            min_spec_number:
                Minimum number of consecutive spectra required for glycan to be accepted
        '''
        spec_dict = {}
        glycopep_dict = {}
        with open(sp_result_file, 'r') as in_file:
            csv_input = csv.DictReader(in_file)
            old_fieldnames = csv_input.fieldnames
            for line_dict in csv_input:
                raw_file = line_dict['Raw Data Name']
                if raw_file not in spec_dict.keys():
                    spec_dict[raw_file] = {}
                spec = int(line_dict['Spectrum ID'])
                if spec not in spec_dict[raw_file].keys():
                    spec_dict[raw_file][spec] = {}
                score = float(line_dict['SugarPy Score'])
                if score not in spec_dict[raw_file][spec].keys():
                    spec_dict[raw_file][spec][score] = set()
                glycopep = '{0}#{1}#{2}'.format(
                    line_dict['Sequence'],
                    line_dict['Modifications'],
                    line_dict['Glycan'],
                )
                spec_dict[raw_file][spec][score].add(glycopep)
                if glycopep not in glycopep_dict.keys():
                    glycopep_dict[glycopep] = []
                glycopep_dict[glycopep].append(line_dict)

        results_dict = {}
        for glycopep in glycopep_dict.keys():
            if glycopep not in results_dict.keys():
                results_dict[glycopep] = {
                    'line_dict_list' : [],
                    'raw_file_set' : set(),
                }
            add_glycopep = False
            for line_dict in glycopep_dict[glycopep]:
                raw_file = line_dict['Raw Data Name']
                all_specs = sorted(spec_dict[raw_file].keys())
                spec = int(line_dict['Spectrum ID'])
                spec_index = all_specs.index(spec)
                consecutive_specs = 0
                for spec in all_specs[spec_index:spec_index + min_spec_number]:
                    if len(spec_dict[raw_file][spec].keys()) < max_trees_per_spec:
                        max_trees_per_spec = len(spec_dict[raw_file][spec].keys())
                    for score in sorted(
                        spec_dict[raw_file][spec].keys(),
                        reverse=True
                    )[:max_trees_per_spec]:
                        if glycopep in spec_dict[raw_file][spec][score]:
                            consecutive_specs +=1
                            break
                if consecutive_specs >= min_spec_number:
                    add_glycopep = True
                    results_dict[glycopep]['raw_file_set'].add(raw_file)    
            if add_glycopep:
                results_dict[glycopep]['line_dict_list'].extend(glycopep_dict[glycopep])

        new_fieldnames = old_fieldnames + ['Num Raw Files']
        output_file_name = sp_result_file.replace('.csv', '_extracted.csv')
        with open(output_file_name, 'w') as out_file:
            if sys.platform == 'win32':
                lineterminator = '\n'
            else:
                lineterminator = '\r\n'
            csv_writer = csv.DictWriter(
                out_file, new_fieldnames, lineterminator=lineterminator)
            csv_writer.writeheader()
            for glycopep in results_dict.keys():
                for line_dict in results_dict[glycopep]['line_dict_list']:
                    line_dict['Num Raw Files'] = len(results_dict[glycopep]['raw_file_set'])
                    csv_writer.writerow(line_dict)

        return output_file_name

if __name__ == '__main__':
    print(__doc__)
